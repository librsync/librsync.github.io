<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<title>librsync: stream.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- ad -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- librsync -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-3547096055927362"
         data-ad-slot="8322976738"
         data-ad-format="auto"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">librsync
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stream.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="stream_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a392863996f0186170daf5b50ab22099b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8c.html#a392863996f0186170daf5b50ab22099b">rs_buffers_copy</a> (<a class="el" href="librsync_8h.html#abf9f543dbfe5c1e60c8ed1c93d087767">rs_buffers_t</a> *stream, int max_len)</td></tr>
<tr class="memdesc:a392863996f0186170daf5b50ab22099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy up to <code>max_len</code> bytes from input of <b>stream</b> to its output.  <a href="stream_8c.html#a392863996f0186170daf5b50ab22099b">More...</a><br /></td></tr>
<tr class="separator:a392863996f0186170daf5b50ab22099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731cde76aa43140e9d8b04675a2ab99a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8c.html#a731cde76aa43140e9d8b04675a2ab99a">rs_buffers_check_exit</a> (<a class="el" href="librsync_8h.html#abf9f543dbfe5c1e60c8ed1c93d087767">rs_buffers_t</a> const *stream)</td></tr>
<tr class="memdesc:a731cde76aa43140e9d8b04675a2ab99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert input is empty or output is full.  <a href="stream_8c.html#a731cde76aa43140e9d8b04675a2ab99a">More...</a><br /></td></tr>
<tr class="separator:a731cde76aa43140e9d8b04675a2ab99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manage librsync streams of IO.</p>
<p>See </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="scoop_8c.html">scoop.c</a> and </dd>
<dd>
<a class="el" href="tube_8c.html">tube.c</a> for related code for input and output respectively.</dd></dl>
<p>OK, so I'll admit IO here is a little complex. The most important player here is the stream, which is an object for managing filter operations. It has both input and output sides, both of which is just a (pointer,len) pair into a buffer provided by the client. The code controlling the stream handles however much data it wants, and the client provides or accepts however much is convenient.</p>
<p>At the same time as being friendly to the client, we also try to be very friendly to the internal code. It wants to be able to ask for arbitrary amounts of input or output and get it without having to keep track of partial completion. So there are functions which either complete, or queue whatever was not sent and return RS_BLOCKED.</p>
<p>The output buffer is a little more clever than simply a data buffer. Instead it knows that we can send either literal data, or data copied through from the input of the stream.</p>
<p>In <a class="el" href="buf_8c.html">buf.c</a> you will find functions that then map buffers onto stdio files.</p>
<p>So on return from an encoding function, either the input or the output or possibly both will have no more bytes available.</p>
<p>librsync never does IO or memory allocation, but relies on the caller. This is very nice for integration, but means that we have to be fairly flexible as to when we can &lsquo;read&rsquo; or &lsquo;write&rsquo; stuff internally.</p>
<p>librsync basically does two types of IO. It reads network integers of various lengths which encode command and control information such as versions and signatures. It also does bulk data transfer.</p>
<p>IO of network integers is internally buffered, because higher levels of the code need to see them transmitted atomically: it's no good to read half of a uint32. So there is a small and fixed length internal buffer which accumulates these. Unlike previous versions of the library, we don't require that the caller hold the start until the whole thing has arrived, which guarantees that we can always make progress.</p>
<p>On each call into a stream iterator, it should begin by trying to flush output. This may well use up all the remaining stream space, in which case nothing else can be done.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>Kill this file and move the vestigial code remaining closer to where it's used. </dd></dl>

<p class="definition">Definition in file <a class="el" href="stream_8c_source.html">stream.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a392863996f0186170daf5b50ab22099b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392863996f0186170daf5b50ab22099b">&#9670;&nbsp;</a></span>rs_buffers_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rs_buffers_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#abf9f543dbfe5c1e60c8ed1c93d087767">rs_buffers_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy up to <code>max_len</code> bytes from input of <b>stream</b> to its output. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually copied, which may be less than LEN if there is not enough space in one or the other stream.</dd></dl>
<p>This always does the copy immediately. Most functions should call <a class="el" href="tube_8c.html#a35e5fd0a62b2311eb2b0ccb71aefd01a" title="Queue up a request to copy through len bytes from the input to the output of the stream.">rs_tube_copy()</a> to cause the copy to happen gradually as space becomes available. </p>

<p class="definition">Definition at line <a class="el" href="stream_8c_source.html#l00096">96</a> of file <a class="el" href="stream_8c_source.html">stream.c</a>.</p>

</div>
</div>
<a id="a731cde76aa43140e9d8b04675a2ab99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731cde76aa43140e9d8b04675a2ab99a">&#9670;&nbsp;</a></span>rs_buffers_check_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rs_buffers_check_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#abf9f543dbfe5c1e60c8ed1c93d087767">rs_buffers_t</a> const *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert input is empty or output is full. </p>
<p>Whenever a stream processing function exits, it should have done so because it has either consumed all the input or has filled the output buffer. This function checks that simple postcondition. </p>

<p class="definition">Definition at line <a class="el" href="stream_8c_source.html#l00134">134</a> of file <a class="el" href="stream_8c_source.html">stream.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<!-- ad -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- librsync -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3547096055927362"
     data-ad-slot="8322976738"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<!-- analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71109100-1', 'auto');
  ga('send', 'pageview');
</script>
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 20 2020 11:57:31 for librsync by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
