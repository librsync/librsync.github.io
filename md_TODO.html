<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>librsync: TODO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- ad -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- librsync -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-3547096055927362"
         data-ad-slot="8322976738"
         data-ad-format="auto"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">librsync
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">TODO </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Fix symbol names:<ul>
<li>Rename all symbols that are intended to be private to <code>rs__</code></li>
<li>Rename those that don't match either prefix.</li>
</ul>
</li>
<li>We have a few functions to do with reading a netint, stashing it somewhere, then moving into a different state. Is it worth writing generic functions for that, or would it be too confusing?</li>
<li><p class="startli">Fix up consecutive matches</p>
<p class="startli">We often have several consecutive matches, and we can combine them into a single COPY command. So far so good.</p>
<p class="startli">In some inputs, there might be several identical blocks.</p>
<p class="startli">When we're matching, we want to prefer to match a block that comes just after the previous match, so that they'll join up nicely into a single larger match. rsync does this; librsync doesn't at the moment. It does cause a measurable problem.</p>
<p class="startli">In fact, we could introduce an additional optimization over rsync. Suppose that the block A occurs twice, once followed by B and once by C. When we first match it, we'll probably make an arbitrary choice of which one to use. But if we next observe C, then it might be better to have given the offset of the A that precedes C, so that they can be joined into a single copy operation.</p>
<p class="startli">This might be a bit complex. You can imagine in fact needing an arbitrarily deep lookback.</p>
<p class="startli">As a simpler optimization, we might just try to prefer matching blocks in the same order that they occur in the input.</p>
<p class="startli">But for now we ought to at least check for consecutive blocks.</p>
<p class="startli">On the other hand, abo says: </p><pre class="fragment"> In reality copy's are such a huge gain that merging them efficiently
 is a bit of a non-issue. Each copy command is only a couple of
 bytes... who cares if we output twice as many as we need to... it's
 the misses that take up whole blocks of data that people will notice.

 I believe we are already outputing consecutive blocks as a single
 "copy" command, but have you looked at the "search" code? We have far
 more serious problems with the hash-table that need to be fixed first
 :-)

 We are not getting all the hits that we could due to a limited
 hash-table, and this is going to make a much bigger difference than
 optimizing the copy commands.
</pre></li>
<li><p class="startli">Optimisations and code cleanups;</p>
<p class="startli"><a class="el" href="scoop_8c_source.html">scoop.c</a>: Scoop needs major refactor. Perhaps the API needs tweaking?</p>
<p class="startli">rsync.h: <a class="el" href="structrs__buffers__s.html" title="Description of input and output buffers. ">rs_buffers_s</a> and rs_buffers_t should be one typedef?</p><ul>
<li>Just how useful is rs_job_drive anyway?</li>
</ul>
<p class="startli"><a class="el" href="patch_8c_source.html">patch.c</a>: rs_patch_s_copying() does alloc, copy free, when it could just copy directly into rs_buffer_t buffer. This <em>does</em> mean the callback can't allocate it's own data, though this can be done by checking if the callback changed the pointer.</p>
<p class="startli"><a class="el" href="mdfour_8c_source.html">mdfour.c</a>: This code has a different API to the RSA code in libmd and is coupled with librsync in unhealthy ways (trace?). Recommend changing to RSA API?</p>
</li>
<li><p class="startli">Don't use the rs_buffers_t structure.</p>
<p class="startli">There's something confusing about the existence of this structure. In part it may be the name. I think people expect that it will be something that behaves like a FILE* or C++ stream, and it really does not. Also, the structure does not behave as an object: it's really just a shorthand for passing values in to the encoding routines, and so does not have a lot of identity of its own.</p>
<p class="startli">An alternative might be</p>
<p class="startli">result = rs_job_iter(job, in_buf, &amp;in_len, in_is_ending, out_buf, &amp;out_len);</p>
<p class="startli">where we update the length parameters on return to show how much we really consumed.</p>
<p class="startli">One technicality here will be to restructure the code so that the input buffers are passed down to the scoop/tube functions that need them, which are relatively deeply embedded. I guess we could just stick them into the job structure, which is becoming a kind of catch-all "environment" for poor C programmers.</p>
</li>
<li>Meta-programming<ul>
<li>Plot lengths of each function</li>
<li>Some kind of statistics on delta each day</li>
</ul>
</li>
<li>Encoding format<ul>
<li>Include a version in the signature and difference fields</li>
<li>Remember to update them if we ever ship a buggy version (nah!) so that other parties can know not to trust the encoded data.</li>
</ul>
</li>
<li><p class="startli">abstract encoding</p>
<p class="startli">In fact, we can vary on several different variables:</p><ul>
<li>what signature format are we using</li>
<li>what command protocol are we using</li>
<li>what search algorithm are we using?</li>
<li>what implementation version are we?</li>
</ul>
<p class="startli">Some are more likely to change than others. We need a chart showing which source files depend on which variable.</p>
</li>
<li>Error handling<ul>
<li>What happens if the user terminates the request?</li>
</ul>
</li>
<li>Encoding implementation<ul>
<li>Join up signature commands</li>
</ul>
</li>
<li>Encoding algorithm<ul>
<li><p class="startli">Self-referential copy commands</p>
<p class="startli">Suppose we have a file with repeating blocks. The gdiff format allows for COPY commands to extend into the <em>output</em> file so that they can easily point this out. By doing this, they get compression as well as differencing.</p>
<p class="startli">It'd be pretty simple to implement this, I think: as we produce output, we'd also generate checksums (using the search block size), and add them to the sum set. Then matches will fall out automatically, although we might have to specially allow for short blocks.</p>
<p class="startli">However, I don't see many files which have repeated 1kB chunks, so I don't know if it would be worthwhile.</p>
</li>
<li><p class="startli">Extended files</p>
<p class="startli">Suppose the new file just has data added to the end. At the moment, we'll match everything but the last block of the old file. It won't match, because at the moment the search block size is only reduced at the end of the <em>new</em> file. This is a little inefficient, because ideally we'd know to look for the last block using the shortened length.</p>
<p class="startli">This is a little hard to implement, though perhaps not impossible. The current rolling search algorithm can only look for one block size at any time. Can we do better? Can we look for all block lengths that could match anything?</p>
<p class="startli">Remember also that at the moment we don't send the block length in the signature; it's implied by the length of the new block that it matches. This is kind of cute, and importantly helps reduce the length of the signature.</p>
</li>
<li><p class="startli">State-machine searching</p>
<p class="startli">Building a state machine from a regular expression is a brilliant idea. (I think <em>The Practice of Programming</em> walks through the construction of this at a fairly simple level.)</p>
<p class="startli">In particular, we can search for any of a large number of alternatives in a very efficient way, with much less effort than it would take to search for each the hard way. Remember also the string-searching algorithms and how much time they can take.</p>
<p class="startli">I wonder if we can use similar principles here rather than the current simple rolling-sum mechanism? Could it let us match variable-length signatures?</p>
</li>
<li><p class="startli">Cross-file matches</p>
<p class="startli">If the downstream server had many similar URLs, it might be nice if it could draw on all of them as a basis. At the moment there's no way to express this, and I think the work of sending up signatures for all of them may be too hard.</p>
<p class="startli">Better just to make sure we choose the best basis if there is none present. Perhaps this needs to weigh several factors.</p>
<p class="startli">One factor might be that larger files are better because they're more likely to have a match. I'm not sure if that's very strong, because they'll just bloat the request. Another is that more recent files might be more useful.</p>
</li>
</ul>
</li>
<li><p class="startli">Support gzip compression of the difference stream. Does this belong here, or should it be in the client and librsync just have an interface that lets it cleanly plug in?</p>
<p class="startli">I think if we're going to just do plain gzip, rather than rsync-gzip, then it might as well be external.</p>
</li>
<li><p class="startli">rsync-gzip: preload with the omitted text so as to get better compression. Abo thinks this gets significantly better compression. On the other hand we have to important and maintain our own zlib fork, at least until we can persuade the upstream to take the necessary patch. Can that be done?</p>
<p class="startli">abo says </p><pre class="fragment"> It does get better compression, but at a price. I actually
 think that getting the code to a point where a feature like
 this can be easily added or removed is more important than the
 feature itself. Having generic pre and post processing layers
 for hit/miss data would be useful. I would not like to see it
 added at all if it tangled and complicated the code.

 It also doesn't require a modified zlib... pysync uses the
 standard zlib to do it by compressing the data, then throwing
 it away. I don't know how much benefit the rsync modifications
 to zlib actually are, but if I was implementing it I would
 stick to a stock zlib until it proved significantly better to
 go with the fork.
</pre></li>
<li><p class="startli">Licensing</p>
<p class="startli">Will the GNU Lesser GPL work? Specifically, will it be a problem in distributing this with Mozilla or Apache?</p>
</li>
<li>Checksums<ul>
<li><p class="startli">Do we really need to require that signatures arrive after the data they describe? Does it make sense in HTTP to resume an interrupted transfer?</p>
<p class="startli">I hope we can do this. If we can't, however, then we should relax this constraint and allow signatures to arrive before the data they describe. (Really? Do we care?)</p>
</li>
<li>Allow variable-length checksums in the signature; the signature will have to describe the length of the sums and we must compare them taking this into account.</li>
</ul>
</li>
<li>Testing<ul>
<li>Just more testing in general.</li>
<li>Test broken pipes and that IO errors are handled properly.</li>
<li>Test files &gt;2GB, &gt;4GB. Presumably these must be done in streams so that the disk requirements to run the test suite are not too ridiculous. I wonder if it will take too long to run these tests? Probably, but perhaps we can afford to run just one carefully-chosen test.</li>
<li>Fuzz instruction streams. <a href="https://code.google.com/p/american-fuzzy-lop/">https://code.google.com/p/american-fuzzy-lop/</a>?</li>
<li>Generate random data; do random mutations.</li>
<li>Try different block lengths.</li>
<li>Tests should fail if they can't find their inputs, or have zero inputs: at present they tend to succeed by default.</li>
<li>Test varying strong-sum inputs: default, short, long.</li>
</ul>
</li>
<li>Security audit<ul>
<li>If this code was to read differences or sums from random machines on the network, then it's a security boundary. Make sure that corrupt input data can't make the program crash or misbehave.</li>
</ul>
</li>
<li>Use slprintf not strnprintf, etc.</li>
<li>Long files<ul>
<li>How do we handle the large signatures required to support large files? In particular, how do we choose an appropriate block size when the length is unknown? Perhaps we should allow a way for the signature to scale up as it grows.</li>
<li>What do we need to do to compile in support for this?<ul>
<li>On GNU, defining <code>_LARGEFILE_SOURCE</code> as we now do should be sufficient.</li>
<li>SCO and similar things on 32-bit platforms may be more difficult. Some SCO systems have no 64-bit types at all, so there we will have to do without.</li>
<li>On larger Unix platforms we hope that large file support will be the default.</li>
</ul>
</li>
</ul>
</li>
<li>Perhaps make extracted signatures still be wrapped in commands. What would this lead to?<ul>
<li>We'd know how much signature data we expect to read, rather than requiring it to be terminated by the caller.</li>
</ul>
</li>
<li>Only use <code>inline</code> if the compiler supports it; perhaps allow it to be disabled or even just let the compiler decide?</li>
<li>Fall back from <code>uint8_t</code> to probably <code>unsigned char</code> if necessary.</li>
<li>Don't randomly use chars and longs; use rs_byte_t and rs_size_t. </li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<!-- ad -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- librsync -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3547096055927362"
     data-ad-slot="8322976738"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<!-- analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71109100-1', 'auto');
  ga('send', 'pageview');
</script>
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 16 2017 05:03:40 for librsync by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
