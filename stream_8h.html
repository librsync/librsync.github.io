<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>librsync: stream.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- ad -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- librsync -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-3547096055927362"
         data-ad-slot="8322976738"
         data-ad-format="auto"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">librsync
   &#160;<span id="projectnumber">2.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stream.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manage librsync streams of IO.  
<a href="#details">More...</a></p>

<p><a href="stream_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad7bc279a3c8fa1a2fc0316f13e2c6e25"><td class="memItemLeft" align="right" valign="top"><a id="ad7bc279a3c8fa1a2fc0316f13e2c6e25"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>rs_buffers_copy</b> (<a class="el" href="librsync_8h.html#abf9f543dbfe5c1e60c8ed1c93d087767">rs_buffers_t</a> *stream, size_t len)</td></tr>
<tr class="separator:ad7bc279a3c8fa1a2fc0316f13e2c6e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285265e3d220e43b8fd08867d708d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a5285265e3d220e43b8fd08867d708d9c">rs_tube_catchup</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job)</td></tr>
<tr class="memdesc:a5285265e3d220e43b8fd08867d708d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put whatever will fit from the tube into the output of the stream.  <a href="stream_8h.html#a5285265e3d220e43b8fd08867d708d9c">More...</a><br /></td></tr>
<tr class="separator:a5285265e3d220e43b8fd08867d708d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa78a2f17f45a022ec0f93a50c3f142d"><td class="memItemLeft" align="right" valign="top"><a id="afa78a2f17f45a022ec0f93a50c3f142d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rs_tube_is_idle</b> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> const *job)</td></tr>
<tr class="separator:afa78a2f17f45a022ec0f93a50c3f142d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f3b8fcc410948351d62728018ec67d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a98f3b8fcc410948351d62728018ec67d">rs_tube_write</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, void const *buf, size_t len)</td></tr>
<tr class="memdesc:a98f3b8fcc410948351d62728018ec67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push some data into the tube for storage.  <a href="stream_8h.html#a98f3b8fcc410948351d62728018ec67d">More...</a><br /></td></tr>
<tr class="separator:a98f3b8fcc410948351d62728018ec67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1170d5552b5581630f90d8a66a71adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa1170d5552b5581630f90d8a66a71adc">rs_tube_copy</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, size_t len)</td></tr>
<tr class="memdesc:aa1170d5552b5581630f90d8a66a71adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue up a request to copy through <code>len</code> bytes from the input to the output of the stream.  <a href="stream_8h.html#aa1170d5552b5581630f90d8a66a71adc">More...</a><br /></td></tr>
<tr class="separator:aa1170d5552b5581630f90d8a66a71adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d4039d1b2ab513e3682925eb66d2cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa8d4039d1b2ab513e3682925eb66d2cd">rs_scoop_input</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, size_t len)</td></tr>
<tr class="memdesc:aa8d4039d1b2ab513e3682925eb66d2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to accept a from the input buffer to get LEN bytes in the scoop.  <a href="stream_8h.html#aa8d4039d1b2ab513e3682925eb66d2cd">More...</a><br /></td></tr>
<tr class="separator:aa8d4039d1b2ab513e3682925eb66d2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e63ccd707266363d6feeca754a370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aad3e63ccd707266363d6feeca754a370">rs_scoop_advance</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, size_t len)</td></tr>
<tr class="memdesc:aad3e63ccd707266363d6feeca754a370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the input cursor forward <code>len</code> bytes.  <a href="stream_8h.html#aad3e63ccd707266363d6feeca754a370">More...</a><br /></td></tr>
<tr class="separator:aad3e63ccd707266363d6feeca754a370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026b9505478d48f4b9b05fea46c166e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a026b9505478d48f4b9b05fea46c166e1">rs_scoop_readahead</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, size_t len, void **ptr)</td></tr>
<tr class="memdesc:a026b9505478d48f4b9b05fea46c166e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from scoop without advancing.  <a href="stream_8h.html#a026b9505478d48f4b9b05fea46c166e1">More...</a><br /></td></tr>
<tr class="separator:a026b9505478d48f4b9b05fea46c166e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb894edc12cd2972a1eb020bdc80725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a9eb894edc12cd2972a1eb020bdc80725">rs_scoop_read</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, size_t len, void **ptr)</td></tr>
<tr class="memdesc:a9eb894edc12cd2972a1eb020bdc80725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LEN bytes if possible, and remove them from the input scoop.  <a href="stream_8h.html#a9eb894edc12cd2972a1eb020bdc80725">More...</a><br /></td></tr>
<tr class="separator:a9eb894edc12cd2972a1eb020bdc80725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c1b8a80bbed23d9409559fa101496b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#af9c1b8a80bbed23d9409559fa101496b">rs_scoop_read_rest</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job, size_t *len, void **ptr)</td></tr>
<tr class="memdesc:af9c1b8a80bbed23d9409559fa101496b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read whatever data remains in the input stream.  <a href="stream_8h.html#af9c1b8a80bbed23d9409559fa101496b">More...</a><br /></td></tr>
<tr class="separator:af9c1b8a80bbed23d9409559fa101496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f0ff863d2c2081d79985ff7e35da34"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a26f0ff863d2c2081d79985ff7e35da34">rs_scoop_total_avail</a> (<a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *job)</td></tr>
<tr class="memdesc:a26f0ff863d2c2081d79985ff7e35da34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of bytes available including the scoop and input buffer.  <a href="stream_8h.html#a26f0ff863d2c2081d79985ff7e35da34">More...</a><br /></td></tr>
<tr class="separator:a26f0ff863d2c2081d79985ff7e35da34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manage librsync streams of IO. </p>
<p>See </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="scoop_8c.html" title="This file deals with readahead from caller-supplied buffers.">scoop.c</a> and </dd>
<dd>
<a class="el" href="tube_8c.html" title="A somewhat elastic but fairly small buffer for data passing through a stream.">tube.c</a> for related code for input and output respectively.</dd></dl>
<p>OK, so I'll admit IO here is a little complex. The most important player here is the stream, which is an object for managing filter operations. It has both input and output sides, both of which is just a (pointer,len) pair into a buffer provided by the client. The code controlling the stream handles however much data it wants, and the client provides or accepts however much is convenient.</p>
<p>At the same time as being friendly to the client, we also try to be very friendly to the internal code. It wants to be able to ask for arbitrary amounts of input or output and get it without having to keep track of partial completion. So there are functions which either complete, or queue whatever was not sent and return RS_BLOCKED.</p>
<p>The output buffer is a little more clever than simply a data buffer. Instead it knows that we can send either literal data, or data copied through from the input of the stream.</p>
<p>In <a class="el" href="buf_8c.html" title="Buffers that map between stdio file streams and librsync streams.">buf.c</a> you will find functions that then map buffers onto stdio files.</p>
<p>So on return from an encoding function, either the input or the output or possibly both will have no more bytes available.</p>
<p>librsync never does IO or memory allocation, but relies on the caller. This is very nice for integration, but means that we have to be fairly flexible as to when we can &lsquo;read&rsquo; or &lsquo;write&rsquo; stuff internally.</p>
<p>librsync basically does two types of IO. It reads network integers of various lengths which encode command and control information such as versions and signatures. It also does bulk data transfer.</p>
<p>IO of network integers is internally buffered, because higher levels of the code need to see them transmitted atomically: it's no good to read half of a uint32. So there is a small and fixed length internal buffer which accumulates these. Unlike previous versions of the library, we don't require that the caller hold the start until the whole thing has arrived, which guarantees that we can always make progress.</p>
<p>On each call into a stream iterator, it should begin by trying to flush output. This may well use up all the remaining stream space, in which case nothing else can be done. </p>

<p class="definition">Definition in file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5285265e3d220e43b8fd08867d708d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5285265e3d220e43b8fd08867d708d9c">&#9670;&nbsp;</a></span>rs_tube_catchup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a> rs_tube_catchup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put whatever will fit from the tube into the output of the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>RS_DONE if the tube is now empty and ready to accept another command, RS_BLOCKED if there is still stuff waiting to go out. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tube_8c_source.html#l00159">159</a> of file <a class="el" href="tube_8c_source.html">tube.c</a>.</p>

</div>
</div>
<a id="a98f3b8fcc410948351d62728018ec67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f3b8fcc410948351d62728018ec67d">&#9670;&nbsp;</a></span>rs_tube_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rs_tube_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push some data into the tube for storage. </p>
<p>The tube's never supposed to get very big, so this will just pop loudly if you do that.</p>
<p>We can't accept write data if there's already a copy command in the tube, because the write data comes out first. </p>

<p class="definition">Definition at line <a class="el" href="tube_8c_source.html#l00214">214</a> of file <a class="el" href="tube_8c_source.html">tube.c</a>.</p>

</div>
</div>
<a id="aa1170d5552b5581630f90d8a66a71adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1170d5552b5581630f90d8a66a71adc">&#9670;&nbsp;</a></span>rs_tube_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rs_tube_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue up a request to copy through <code>len</code> bytes from the input to the output of the stream. </p>
<p>The data is copied from the scoop (if there is anything there) or from the input, on the next call to <a class="el" href="tube_8c.html#a15809106e8f91386fb19f3934f73b993" title="Push some data into the tube for storage.">rs_tube_write()</a>.</p>
<p>We can only accept this request if there is no copy command already pending.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Try to do the copy immediately, and return a result. Then, people can try to continue if possible. Is this really required? Callers can just go out and back in again after flushing the tube. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tube_8c_source.html#l00200">200</a> of file <a class="el" href="tube_8c_source.html">tube.c</a>.</p>

</div>
</div>
<a id="aa8d4039d1b2ab513e3682925eb66d2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d4039d1b2ab513e3682925eb66d2cd">&#9670;&nbsp;</a></span>rs_scoop_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rs_scoop_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to accept a from the input buffer to get LEN bytes in the scoop. </p>

<p class="definition">Definition at line <a class="el" href="scoop_8c_source.html#l00067">67</a> of file <a class="el" href="scoop_8c_source.html">scoop.c</a>.</p>

</div>
</div>
<a id="aad3e63ccd707266363d6feeca754a370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e63ccd707266363d6feeca754a370">&#9670;&nbsp;</a></span>rs_scoop_advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rs_scoop_advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the input cursor forward <code>len</code> bytes. </p>
<p>This is used after doing readahead, when you decide you want to keep it. <code>len</code> must be no more than the amount of available data, so you can't cheat.</p>
<p>So when creating a delta, we require one block of readahead. But after examining that block, we might decide to advance over all of it (if there is a match), or just one byte (if not). </p>

<p class="definition">Definition at line <a class="el" href="scoop_8c_source.html#l00117">117</a> of file <a class="el" href="scoop_8c_source.html">scoop.c</a>.</p>

</div>
</div>
<a id="a026b9505478d48f4b9b05fea46c166e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026b9505478d48f4b9b05fea46c166e1">&#9670;&nbsp;</a></span>rs_scoop_readahead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a> rs_scoop_readahead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from scoop without advancing. </p>
<p>Ask for LEN bytes of input from the stream. If that much data is available, then return a pointer to it in PTR, advance the stream input pointer over the data, and return RS_DONE. If there's not enough data, then accept whatever is there into a buffer, advance over it, and return RS_BLOCKED.</p>
<p>The data is not actually removed from the input, so this function lets you do readahead. If you want to keep any of the data, you should also call <a class="el" href="scoop_8c.html#aad3e63ccd707266363d6feeca754a370" title="Advance the input cursor forward len bytes.">rs_scoop_advance()</a> to skip over it. </p>

<p class="definition">Definition at line <a class="el" href="scoop_8c_source.html#l00148">148</a> of file <a class="el" href="scoop_8c_source.html">scoop.c</a>.</p>

</div>
</div>
<a id="a9eb894edc12cd2972a1eb020bdc80725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb894edc12cd2972a1eb020bdc80725">&#9670;&nbsp;</a></span>rs_scoop_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a> rs_scoop_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LEN bytes if possible, and remove them from the input scoop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*job</td><td>An rs_job_t pointer to the job instance.</td></tr>
    <tr><td class="paramname">len</td><td>The length of the data in the ptr buffer.</td></tr>
    <tr><td class="paramname">**ptr</td><td>will be updated to point to a read-only buffer holding the data, if enough is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RS_DONE if there was enough data, RS_BLOCKED if there was not enough data yet, or RS_INPUT_ENDED if there was not enough data and at EOF. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scoop_8c_source.html#l00192">192</a> of file <a class="el" href="scoop_8c_source.html">scoop.c</a>.</p>

</div>
</div>
<a id="af9c1b8a80bbed23d9409559fa101496b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c1b8a80bbed23d9409559fa101496b">&#9670;&nbsp;</a></span>rs_scoop_read_rest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="librsync_8h.html#a7feb858ceba3b8f3cf048d49be108253">rs_result</a> rs_scoop_read_rest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read whatever data remains in the input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*job</td><td>The rs_job_t instance the job instance.</td></tr>
    <tr><td class="paramname">*len</td><td>will be updated to the length of the available data.</td></tr>
    <tr><td class="paramname">**ptr</td><td>will point at the available data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RS_DONE if there was data, RS_INPUT_ENDED if there was no data and at EOF, RS_BLOCKED if there was no data and not at EOF. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scoop_8c_source.html#l00212">212</a> of file <a class="el" href="scoop_8c_source.html">scoop.c</a>.</p>

</div>
</div>
<a id="a26f0ff863d2c2081d79985ff7e35da34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f0ff863d2c2081d79985ff7e35da34">&#9670;&nbsp;</a></span>rs_scoop_total_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rs_scoop_total_avail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="librsync_8h.html#add6622b38e3fa557301a190876d5ed4a">rs_job_t</a> *&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of bytes available including the scoop and input buffer. </p>

<p class="definition">Definition at line <a class="el" href="scoop_8c_source.html#l00227">227</a> of file <a class="el" href="scoop_8c_source.html">scoop.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<!-- ad -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- librsync -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3547096055927362"
     data-ad-slot="8322976738"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<!-- analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71109100-1', 'auto');
  ga('send', 'pageview');
</script>
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 10 2021 15:04:34 for librsync by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
